name: Slack Review Notifications Workflow

on:
  pull_request_review:
    types: [submitted]
  pull_request_review_comment:
    types: [created]
  pull_request:
    types: [review_requested]
  issue_comment:
    types: [created]

jobs:
  send_notification:
    name: Ping Reviewer(s)
    runs-on: ubuntu-latest
    steps:
      - name: Delay Step
        run: sleep 10
        # Delay to ensure GitHub API has processed all events

      - name: Get Current PR
        id: get_pr
        uses: 8BitJonny/gh-get-current-pr@3.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          # For issue_comment events, we need to use a different approach
          sha: ${{ github.event_name != 'issue_comment' && github.event.pull_request.head.sha || '' }}
          # For issue_comment events, we'll use the issue number instead
          issue-number: ${{ github.event_name == 'issue_comment' && github.event.issue.number || '' }}

      - name: Send Slack Notification
        if: ${{ !contains(steps.get_pr.outputs.pr_labels, 'hotfix') }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_J_DM_URL }}
          PR_OBJECT: ${{ steps.get_pr.outputs.pr }}
          GITHUB_ACTOR: ${{ github.actor }}
          PR_URL: ${{ steps.get_pr.outputs.pr_url }}
          PR_NUMBER: ${{ steps.get_pr.outputs.number }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_ACTION: ${{ github.event.action }}
          GITHUB_EVENT_REVIEW_STATE: ${{ github.event.review.state }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_OBJECT: ${{ toJSON(github.event.issue) }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        shell: python
        run: |
          import os, json, requests
          
          class EnvironmentVariableExtractor:
              """Class responsible for extracting and normalizing environment variables"""
              
              def __init__(self):
                  self.event_name = os.getenv('GITHUB_EVENT_NAME')
                  self.event_action = os.getenv('GITHUB_EVENT_ACTION')
                  self.review_state = os.getenv('GITHUB_EVENT_REVIEW_STATE')
                  self.actor = os.getenv('GITHUB_ACTOR')
                  
                  # Initialize PR data
                  self.pr_url = os.getenv('PR_URL')
                  self.pr_number = os.getenv('PR_NUMBER')
                  self.pr_author = None
                  self.reviewers = []
                  
                  # Extract data based on event type
                  if self.event_name == 'issue_comment':
                      self._extract_from_issue_object()
                  else:
                      self._extract_from_pr_object()
              
              def _extract_from_pr_object(self):
                  """Extract data from PR object for regular PR events"""
                  pr_object_str = os.getenv('PR_OBJECT')
                  if not pr_object_str:
                      return
                      
                  try:
                      pr_object = json.loads(pr_object_str)
                      self.reviewers = pr_object.get('requested_reviewers', [])
                      self.pr_author = pr_object.get('user', {}).get('login')
                  except json.JSONDecodeError:
                      print("Warning: Could not decode PR_OBJECT JSON")
              
              def _extract_from_issue_object(self):
                  """Extract data from issue object for issue comment events"""
                  issue_object_str = os.getenv('ISSUE_OBJECT')
                  if not issue_object_str:
                      return
                      
                  try:
                      issue_object = json.loads(issue_object_str)
                      
                      # Check if this is a PR (issues with pull_request property are PRs)
                      if 'pull_request' in issue_object:
                          self.pr_url = issue_object['pull_request']['html_url']
                          self.pr_number = issue_object['number']
                          self.pr_author = issue_object.get('user', {}).get('login')
                  except (json.JSONDecodeError, KeyError) as e:
                      print(f"Warning: Could not process issue object: {e}")
          
          
          class SlackUserMapper:
              """Class responsible for mapping GitHub usernames to Slack user IDs"""
              
              def __init__(self):
                  self.user_map = {
                      'StuartH1': 'U067BG3JC1K',
                      'jake94a': 'U03CVABRQNN',
                      'zenzenzen': 'U04119RP19C'
                  }
              
              def get_slack_mention(self, github_username):
                  """Convert GitHub username to Slack mention format if available"""
                  if github_username in self.user_map:
                      return f"<@{self.user_map[github_username]}>"
                  return github_username
              
              def get_reviewer_mentions(self, reviewers):
                  """Get Slack mentions for a list of reviewers"""
                  mentions = []
                  for reviewer in reviewers:
                      login = reviewer.get('login')
                      if login and login in self.user_map:
                          mentions.append(self.get_slack_mention(login))
                  return ' '.join(mentions)
          
          
          class MessageFactory:
              """Factory class for creating appropriate messages based on event type"""
              
              def __init__(self, env_data, user_mapper):
                  self.env = env_data
                  self.user_mapper = user_mapper
                  
                  # Create common message components
                  self.actor_mention = self.user_mapper.get_slack_mention(self.env.actor)
                  self.author_mention = self.user_mapper.get_slack_mention(self.env.pr_author) if self.env.pr_author else ""
                  self.reviewer_mentions = self.user_mapper.get_reviewer_mentions(self.env.reviewers)
                  
                  # Register message handlers
                  self.message_handlers = {
                      ('pull_request', 'review_requested'): self._handle_review_requested,
                      ('pull_request_review_comment', 'created'): self._handle_review_comment,
                      ('pull_request_review', 'submitted'): self._handle_review_submitted,
                      ('issue_comment', 'created'): self._handle_issue_comment
                  }
              
              def create_message(self):
                  """Create appropriate message based on event type"""
                  handler_key = (self.env.event_name, self.env.event_action)
                  
                  if handler_key in self.message_handlers:
                      return self.message_handlers[handler_key]()
                  
                  return None
              
              def _handle_review_requested(self):
                  """Handle review request event"""
                  return f"{self.reviewer_mentions} *{self.env.actor}* requested your review on <{self.env.pr_url}|PR #{self.env.pr_number}>."
              
              def _handle_review_comment(self):
                  """Handle review comment event"""
                  return f"{self.author_mention} *{self.env.actor}* commented on your code in <{self.env.pr_url}|PR #{self.env.pr_number}>."
              
              def _handle_review_submitted(self):
                  """Handle review submission event with different states"""
                  if self.env.review_state == 'changes_requested':
                      return f"{self.author_mention} *{self.env.actor}* requested changes on your <{self.env.pr_url}|PR #{self.env.pr_number}>."
                  elif self.env.review_state == 'approved':
                      return f"{self.author_mention} *{self.env.actor}* approved your <{self.env.pr_url}|PR #{self.env.pr_number}>."
                  elif self.env.review_state == 'commented':
                      return f"{self.author_mention} *{self.env.actor}* reviewed and commented on your <{self.env.pr_url}|PR #{self.env.pr_number}>."
                  return None
              
              def _handle_issue_comment(self):
                  """Handle issue comment event"""
                  if self.author_mention:
                      return f"{self.author_mention} *{self.env.actor}* commented on your PR conversation in <{self.env.pr_url}|PR #{self.env.pr_number}>."
                  return f"*{self.env.actor}* commented on PR conversation in <{self.env.pr_url}|PR #{self.env.pr_number}>."
          
          
          class SlackNotifier:
              """Class responsible for sending notifications to Slack"""
              
              def __init__(self):
                  self.webhook_url = os.getenv('SLACK_WEBHOOK_URL')
                  self.github_token = os.getenv('GITHUB_TOKEN')
                  self.pr_number = os.getenv('PR_NUMBER')
                  self.repo = os.getenv('GITHUB_REPOSITORY')
              
              def _get_thread_ts(self):
                  """Get thread timestamp from PR description or comments"""
                  if not self.github_token or not self.pr_number or not self.repo:
                      return None
                      
                  try:
                      # Get PR details to check for thread_ts in the body
                      headers = {'Authorization': f'token {self.github_token}'}
                      pr_url = f"https://api.github.com/repos/{self.repo}/pulls/{self.pr_number}"
                      pr_response = requests.get(pr_url, headers=headers)
                      pr_data = pr_response.json()
                      
                      # Look for thread_ts in PR body
                      body = pr_data.get('body', '') or ''
                      import re
                      thread_match = re.search(r'<!-- SLACK_THREAD_TS: ([\d\.]+) -->', body)
                      if thread_match:
                          return thread_match.group(1)
                          
                      return None
                  except Exception as e:
                      print(f"Error retrieving thread timestamp: {e}")
                      return None
              
              def _store_thread_ts(self, thread_ts):
                  """Store thread timestamp in PR description"""
                  if not self.github_token or not self.pr_number or not self.repo:
                      return
                      
                  try:
                      headers = {'Authorization': f'token {self.github_token}'}
                      pr_url = f"https://api.github.com/repos/{self.repo}/pulls/{self.pr_number}"
                      
                      # Get current PR body
                      pr_response = requests.get(pr_url, headers=headers)
                      pr_data = pr_response.json()
                      current_body = pr_data.get('body', '') or ''
                      
                      # Add thread_ts if not already present
                      if '<!-- SLACK_THREAD_TS:' not in current_body:
                          new_body = current_body + f"\n\n<!-- SLACK_THREAD_TS: {thread_ts} -->"
                          patch_data = {'body': new_body}
                          requests.patch(pr_url, headers=headers, json=patch_data)
                  except Exception as e:
                      print(f"Error storing thread timestamp: {e}")
              
              def send_notification(self, message):
                  """Send notification to Slack"""
                  if not message:
                      print("No message to send, skipping Slack notification")
                      return
                  
                  event_name = os.getenv('GITHUB_EVENT_NAME')
                  event_action = os.getenv('GITHUB_EVENT_ACTION')
                  
                  # Get thread_ts for threading if this is not a review request
                  thread_ts = None
                  if not (event_name == 'pull_request' and event_action == 'review_requested'):
                      thread_ts = self._get_thread_ts()
                  
                  payload = {
                      'text': message,
                      'username': 'GitHub Actions',
                      'icon_emoji': ':octocat:',
                  }
                  
                  # Add thread_ts if available for threading
                  if thread_ts:
                      payload['thread_ts'] = thread_ts
                  
                  response = requests.post(self.webhook_url, json=payload)
                  if response.status_code != 200:
                      print(f"Error sending Slack notification: {response.status_code} {response.text}")
                      return
                  
                  # Store thread_ts for future reference if this is the initial message
                  if not thread_ts and (event_name == 'pull_request' and event_action == 'review_requested'):
                      response_data = response.json()
                      if response_data.get('ok') and 'ts' in response_data:
                          self._store_thread_ts(response_data['ts'])
          
          
          def main():
              """Main function to orchestrate the notification process"""
              # Extract environment variables
              env_extractor = EnvironmentVariableExtractor()
              
              # Create user mapper
              user_mapper = SlackUserMapper()
              
              # Create message factory
              message_factory = MessageFactory(env_extractor, user_mapper)
              
              # Create message
              message = message_factory.create_message()
              
              # Send notification
              notifier = SlackNotifier()
              notifier.send_notification(message)
          
          
          # Execute main function
          if __name__ == "__main__":
              main()